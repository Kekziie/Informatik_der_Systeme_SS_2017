\documentclass[paper=a4, fontsize=11pt]{scrartcl} 
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Kim Thuong Ngo}


\usepackage[T1]{fontenc} 
\usepackage{fourier} 

\usepackage{lipsum} 

\usepackage{listings}
\usepackage{graphicx}
\usepackage{tabularx}

\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape} 

\usepackage{fancyhdr} 
\pagestyle{fancyplain} 
\fancyhead{}
\fancyfoot[L]{} 
\fancyfoot[C]{} 
\fancyfoot[R]{\thepage} 
\renewcommand{\headrulewidth}{0pt} 
\renewcommand{\footrulewidth}{0pt}
\setlength{\headheight}{13.6pt}

\numberwithin{equation}{section} 
\numberwithin{figure}{section} 
\numberwithin{table}{section}

\setlength\parindent{0pt} 

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 

\title{	
\normalfont \normalsize 
\textsc{Informatik der Systeme} \\ [25pt] 
\horrule{0.5pt} \\[0.4cm] 
\huge Aufgaben \\ 
\horrule{2pt} \\[0.5cm] 
}

\author{Kim Thuong Ngo} 

\date{\normalsize\today} 

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle 

\newpage

\tableofcontents

\newpage

%----------------------------------------------------------------------------------------
\section{Zahlensysteme}
\section{Interpretation von Hexadezimalzahlen}
In den folgenden Tabelle sind in den ersten Spalten Zahlen im Hexadezimalsystem angegeben. Ergänzen Sie die folgende Tabelle von A)-E)! \\

\begin{itemize}
\item[a)] Schreiben Sie die hexadezimale Zahl als binären String. Dabei soll der binäre String genauso viele Stellen besitzen, um jede zweistellige Hexadezimalzahl darstellen zu können.
\item[b)] Interpretieren Sie den binären String aus a) als vorzeichenlose Binärzahl. Geben Sie die Zahl im Dezimalsystem an.
\item[c)] Interpretieren Sie den binären String aus a) als Zweierkomplement. Geben Sie die Zahl im Dezimalsystem an. 
\item[d)] Negieren Sie die Zahl aus c) und schreiben Sie diesen Wert als binären String im Zweierkomplement auf. 
\item[e)] Schreiben Sie die Zahl aus c) als 16-stelligen binären String im Zweierkomplement aus.
\end{itemize}

\begin{tabular}{|c|c|c|c|c|c|}
\hline
& A) & B) & C) & D) & E) \\
\hline
0x20 & 0010 000$0_{2}$ & $32_{10}$ & $32_{10}$ & 1110 000$0_{2}$ & 0000 0000 0010 000$0_{2}$ \\
\hline
0xA2 & 1010 001$0_{2}$ & $162_{10}$ & $-94_{10}$ & 0101 111$0_{2}$ & 1111 1111 1010 001$0_{2}$ \\
\hline
0x9F & 1001 111$1_{2}$ & $159_{10}$ & $-97_{10}$ & 0110 000$1_{2}$ & 1111 1111 1001 111$1_{2}$ \\
\hline
0xC2 & 1100 001$0_{2}$ & $194_{10}$ & $-62_{10}$ & 0011 111$0_{2}$ & 1111 1111 1100 001$0_{2}$ \\
\hline
0x54 & 0101 010$0_{2}$ & $84_{10}$ & $84_{10}$ & 1010 110$0_{2}$ & 0000 0000 0101 010$0_{2}$ \\
\hline
0x92 & 1001 001$0_{2}$ & $146_{10}$ & $146_{10}$ & 0110 111$0_{2}$ & 1111 1111 1001 001$0_{2}$ \\
\hline
0x3C & 0011 110$0_{2}$ & $60_{10}$ & $196_{10}$ & 1100 010$0_{2}$ & 0000 0000 0011 110$0_{2}$ \\
\hline
\end{tabular} \\

%--------------------------------------------------
\section{Umwandlung von Dezimalzahlen}
In der folgenden Tabelle sind in der ersten Spalte Zahlen im Dezimalsystem angegeben. Ergänzen Sie die folgende Tabelle von A)-C)!

\begin{itemize}
\item[a)] Schreiben Sie den Absolutbetrag der Dezimalzahl als Hexadezimalzahl auf.
\item[b)] Schreiben Sie den Absolutbetrag der Dezimalzahl als binären String auf. 
\item[c)] Schreiben Sie die Dezimalzahl als binären String im Zweierkomplement auf.
\end{itemize}

\begin{tabular}{|c|c|c|c|}
\hline
 & A) & B) & C) \\
\hline 
-24 & 0x18 & 0001 100$0_{2}$ & 1110 100$0_{2}$ \\
\hline
-119  & 0x77 & 0111 011$1_{2}$ & 1000 100$1_{2}$ \\
\hline
82   & 0x52 & 0101 001$0_{2}$ & 0101 001$0_{2}$ \\
\hline
125  & 0x7D & 0111 110$1_{2}$ & 0111 110$1_{2}$ \\
\hline
-17   & 0x19 & 0001 100$1_{2}$ & 1110 011$1_{2}$ \\
\hline
\end{tabular}

%----------------------------------------------------------------------------------------
\section{Gleitkommazahl in IEEE 754 }
\subsection{Umwandlung einer dezimalen Gleitkommazahl in eine hexadezimal codierte IEEE 754 Zahl}
Der 16-Bit Gleitkommatyp binary16 des IEEE-Standards 754 verwendet 1 Bit für das Vorzeichen s, 5 Bit für den Exponenten E und 10 Bit um f, den expliziten Teil der Mantisse zu speichern. Codieren Sie die Zahl $X=\dfrac{1}{125}$ in diesem Format und stellen Sie den daraus resultierende Bitfolge als Hexadezimalzahl dar! \\

\paragraph{1.}
Bringen Sie die Zahl X in das Format $X=(-1)^{s}*(1+f)*2^{e}$ mit $s \epsilon \{0,1 \}$, $e \epsilon \mathbb{Z}$, $B=15$, $E=e+B$, $E \epsilon \mathbb{N}$ und $0 \leqslant f < 1$! \\

$X=\dfrac{1}{125}=0,008$ \\
da X positiv, s=0 \\

\paragraph{2.}
Ermitteln Sie die Repräsentation für s,E und f in Binärschreibweise! \\

\paragraph{3.}
Fügen Sie die 16 Bit in der richtigen Reihenfolge zusammen! \\

Reihenfolge: Sign Bit, Exponent, Mantisse \\

\paragraph{4.}
Warum ist die im Standard vorgeschriebene Reihenfolge sinnvoller als andere Anordnungsmöglichkeiten? \\

lexikalische Ordnung $\rightarrow$ Vergleichsoperationen effizient durchführbar

\paragraph{5.}
Geben Sie die ermittelte Bitfolge in (kompakter) hexadezimaler Darstellung an! \\

%--------------------------------------------------

\subsection{Umwandlung einer hexadezimal codierten IEEE 754 Zahl in eine dezimal codierte Gleitkommazahl}

Welche dezimale Gleitkommazahl stellt $BCDE_{16}$ dar, wenn man IEEE 754 Codierung wie in der vorherigen Aufgabe zu Grunde legt? \\

$X=BCDE_{16}$ \\
$BCDE_{16} \rightarrow$ 1011 1100 1101 111$0_{2}$ \\

%----------------------------------------------------------------------------------------

\section{Kommunikationsnetze, Restklassenrechnung und Huffman-Code}

\subsection{Schichten in Kommunikationsnetzen}
Ein Host in einem WLAN-Netz fragt über HTTP/ TCP/ IP bei einem Webserver eine Webseite an. Das Datenpaket wird von diesem Host über ein WLAN-Netz an einen IP-Router gesendet, der dieses über ein Ethernet-Netz an einen Switch und von dort aus an den Web-Server weiterleitet. \\

\paragraph{1.}
Zu welchen Schichten des ISO/OSI-Schichtenmodells gehören die Protokolle HTTP, TCP, IP, WLAN und Ethernet? Recherchieren Sie dazu im Internet! \\

Sieben-Schichtenmodell: \\
\begin{tabular}{|c|c|}
\hline
7 Application & Anwendung \\
\hline
6 Presentation & Darstellung \\
\hline
5 Session & Kommunikationssteuerung \\
\hline
4 Transport & Transport \\
\hline
3 Network & Vermittlung \\
\hline
2 Data Link & Sicherung \\
\hline
1 Physical & Bitübertragung\\
\hline
\end{tabular}

\paragraph{2.}
Durch welche Technologie wird die IP-Zieladresse des Webservers vom anfragenden Host ermittelt? \\

\paragraph{3.}
Wie oben beschrieben wird das Datenpaket nun versendet. Erklären Sie kurz was mit dem Paket passiert.

%--------------------------------------------------
\subsection{Polynom-Restklassenrechnung}

\paragraph{1.}
Überprüfen Sie, ob die folgenden Polynome primitiv sind:

\begin{center}
$g_{1}(u)=u^{4}+u^{3}+1$ \\
$g_{2}(u)=u^{4}+u^{2}+u+1$ \\
$g_{3}(u)=u^{4}+u^{3}+u+1$ \\
\end{center}

\paragraph{2.}
Welche Polynome sind durch u+1 teilbar? \\

\paragraph{3.}
Können Sie eine einfache Regel aufstellen, anhand der man schnell entscheiden kann, ob ein Polynom durch u+1 teilbar ist? \\

%--------------------------------------------------
\subsection{Huffman-Code}
Der Huffman-Code bietet eine Möglichkeit einen Code mit minimaler mittlerer Codewortlänge zu konstruieren. Es wird folgende Codiervorschrift angewandt: \\

1. Die Zeichen einer Quelle werden in einer Tabelle nach fallenden Auftrittswahrscheinlichkeiten aufgelistet und die Auftrittswahrscheinlichkeiten werden eingetragen. \\
2. Die beiden kleinstwahrscheinlichen Zeichen x,y werden zur Unterscheidung mit 0 und 1 codiert und in der Tabelle entsprechend gekennzeichnet. \\
3. Die beiden Zeichen x und y werden zu einem neuen Zeichen xy zusammengefasst. Dem neuen Zeichen wird die Summe der Wahrscheinlichkeiten der beiden ursprünglichen Zeichen zugeordnet. Die so entstehende Quelle hat ein Zeichen weniger. Falls die neue Quelle nur noch ein Zeichen enthält, fährt man mit Schritt 4 fort, sonst wiederholt man den Algorithmus ab Schritt 1 mit der neuen Quelle. \\
4. Man beginnt mit der letzten Tabelle, arbeitet sich bis zur ersten Tabelle vor und stellt den Codebaum auf. Pro Tabelle erhält man eine Codierentscheidung, d.h. zwei Zweige des Codebaumes. Die Endknoten liefern die gewünschte Codierung. \\

Das Zeichenalphabet einer Nachrichtenquelle umfasste 7 Zeichen $x_{1}, ..., x_{7}$, die mit folgenden Wahrscheinlichkeiten auftreten: 

\begin{center}
\begin{tabular}{|c||c|c|c|c|c|c|c|}
\hline
$x_{i}$ & $x_{1}$ & $x_{2}$ & $x_{3}$ & $x_{4}$ & $x_{5}$ & $x_{6}$ & $x_{7}$ \\
\hline
$p(x_{i})$ & 0,10 & 0,30 & 0,10 & 0,10 & 0,15 & 0,10 & 0,15 \\
\hline
\end{tabular}
\end{center}
\\

\paragraph{1.}
Wie groß ist der Informationsgehalt H* der Nachrichtenquelle? \\

\paragraph{2.}
Man gebe die Optimalcodierung des Zeichenalphabets mit Hilfe des Verfahrens von Huffman an! \\

\paragraph{3.}
Wie groß ist die Coderedundanz $R_{c}$? Man vergleiche diesen Wert mit dem entsprechenden Wert für die Codierung mit einheitlicher Binärstellenzahl.

%----------------------------------------------------------------------------------------
\section{Code}
\subsection{Linear systematischer Code}
Bei einer digitalen Nachrichtenübertragung sollen mit einem linearen systematischen Code 2 Fehler erkannt und 1 Fehler sicher korrigiert werden können.

\paragraph{1.}
Bestimmen Sie die Code-Effizienz $\dfrac{m}{n} = f(k), k=1,2, ..., 12$ und stellen Sie diese graphisch dar. 

\paragraph{2.}
Geben Sie ein Prüfschema für eine Codierung mit $m = 11$ Nutzbits an!

\paragraph{3.}
Wie lauten die Kontrollstellen für das Codewort mit den Nachrichtenstellen 0110 1010 110?

\paragraph{4.}
Man gebe das Fehlersyndrom für folgende Fälle an:
\begin{itemize}
\item[a)] ein Fehler in Stelle $x_{4}$,
\item[b)] je ein Fehler in den Stellen $x_{4}$ und $x_{9}$,
\item[c)] je ein Fehler in den Stellen $x_{4}$,$x_{7}$ und $x_{9}$
\end{itemize}

%--------------------------------------------------
\subsection{Binärer Gruppencode}
Ein Gruppen-Code ist durch die folgenden drei Generatorworte definiert:

$$G_{1}: 01100$$
$$G_{2}: 10010$$
$$G_{3}: 10101$$

\paragraph{1.}
Wie groß ist die Anzahl der Nutz- und Codeworte? Stellen Sie die Liste aller Nutzworte und Codeworte auf!

\paragraph{2.}
Geben Sie die Gewichtsverteilung $A(w), w=0,1, ...,n$ dieses Codes an!

\paragraph{3.}
Wie groß ist die Hamming Distanz h?

\paragraph{4.}
Geben Sie ein Beispiel für ein vom Empfänger nicht als falsch erkennbares Fehlermuster $F_{n}$ an.

\paragraph{5.}
Statt der Generatorworte $G_{1}, G_{2}, G_{3}$ sollen aus der Liste aller Codeworte aus Teilaufgabe 1) drei andere Codeworte als neue Generatorworte $G_{1}*, G_{2}*, G_{3}*$ so ausgewählt werden, dass sich die Nachrichtenstellen in den ersten Stellen der auf dieser Basis konstuierten Codeworte direkt wiederfinden. Wie lauten diese $G_{1}*, G_{2}*, G_{3}*$?

%--------------------------------------------------
\subsection{Restfehler bei Hamming-Codes}
\paragraph{1.}
Sei p die Bitfehlerwahrscheinlichkeit. Mit welcher Wahrscheinlichkeit wird eine Nachricht aus m Bits korrekt übertragen?

\paragraph{2.}
Mit welcher Wahrscheinlichkeit tritt genau ein Bitfehler auf?

\paragraph{3.}
Mit welcher Wahrscheinlichkeit wird ein n-stelliges Codewort eines Hamming-Codes korrekt empfangen oder kann korrekt korrigiert werden?

%----------------------------------------------------------------------------------------
\section{Code und CPU}
\subsection{Zyklischer Code}
Für einen zyklischen Code ist folgendes Generatorpolynom vorgegeben:
$$G(u)=u^{4}+u^{2}+u+1=10111$$

\paragraph{1.}
Bestimmen Sie die Periode dieses Generatorpolynoms!

\paragraph{2.}
Wie groß ist die Zahl m der Nutzbits des entsprechenden zyklischen Codes?

\paragraph{3.}
Ermitteln Sie die Prüfstellen für folgendes Nutzwort 001!

\paragraph{4.}
Zerlegen Sie $G(u)$ in seine primitiven Teiler!

\paragraph{5.}
Um was für einen Code handelt es sich also?

%--------------------------------------------------
\subsection{Taktrate, ISA und CPU-Zeit}
Im Folgenden wir der Zusammenhang zwischen Taktrate, ISA und CPU-Zeit vertieft.

\paragraph{1.}
Ein Rechner A mit einer Taktrate von $2GHz$ benötigt für die Ausführung eines Programms 9 Sekunden. Wie viele Taktzyklen hat er dabei ausgeführt?

\paragraph{2.}
Rechner B hat für speziell das oben betrachtete Programm einen um $25 \%$ höheren $CPI_{eff}$ verglichen mit Rechner A. Welche Taktrate benötigt B, damit er dasselbe Programm mit einer Laufzeit von 6 Sekunden abarbeiten kann.

\paragraph{3.}
Wie viel mal schneller ist dann Rechner B als Rechner A?

%--------------------------------------------------
\subsection{CPU Instruktion und Laufzeit}
Die in einem Programm verwendeten Befehle sind in Tabelle 1 aufgelistet. Die Tabelle enthält die Häufigkeit und die CPI der einzelnen Befehle, welche im Programm vorkommen.

\underline{Tabelle 1}
Häufigkeiten und CPI von Befehlen eines Programms
\begin{tabular}{c|c|c}
Instruktion & Häufigkeit & CPI \\
\hline
ALU & $50 \%$ & 1 \\
\hline
Load & $20 \%$ & 5 \\
\hline
Store & $10 \%$ & 3 \\
\hline
Branch & $20 \%$ & 2 \\
\end{tabular}

\paragraph{1.}
Berechnen Sie die effektive CPI für das Programm.

\paragraph{2.}
Wie viel schneller würde das Programm laufen, wenn ein besser Daten-Cache die durchschnittliche Ladezeit auf 2 CPI reduziert?

\paragraph{3.}
Wie viel schneller würde das Programm laufen. wenn eine verbesserte Sprungvorhersage die CPI für den Branch-Befehl um eins verringert?

\paragraph{4.}
Angenommen zwei ALU Instruktionen können gleichzeitig ausgeführt werden. Wie viel schneller würde das Programm laufen?

%----------------------------------------------------------------------------------------
\section{Maschinencode/ Assemblercode}
\subsection{Lesen von Maschinencode}
Wandeln Sie folgendes Stück Maschinencode zurück in Assemblercode:

Welche Funktion implementiert dieser Code?

%--------------------------------------------------
\subsection{Umwandlung von Assemblercode zu Maschinencode}
Übersetzen Sie das folgende Listing in Maschinencode für den DLX-Prozessor. Geben Sie jedes Maschinencode-Befehlswort auch in kompakter hexadezimaler Darstellung an.

%----------------------------------------------------------------------------------------
\section{Leaf and Non-Leaf Procedures}

\paragraph{1.}
Übersetzen Sie die iterative Prozedur in den MIPS-Assembler Code, der in der Vorlesung vorgestellt wurde!

\paragraph{2.}
Wie viele Register benötigen Sie für die beiden unterschiedlichen Umsetzungen?

\paragraph{3.}
Wie viele Funktionsausrufe werden jeweils benötigt um das 4. Fibonacci-Element zu berechnen?

\paragraph{4.}
Illustrieren Sie für die rekursiv programmierte Funktion die Stack-Belegung in der tiefsten Rekursionsstufe, die benötigt wird, um das 4.Fibonacci-Element zu berechnen!

%----------------------------------------------------------------------------------------
\section{Übersetzung}
\subsection{Übersetzungsvorgang}

\paragraph{1. Präprozessor}
Lassen Sie sich den Output des Präprozessors anzeigen, wenn er auf den oben angegeben C-Code angwendet wird. \\
Was hat sich im Vergleich zum Originalcode geändert? \\
Welche Aufgaben hat der Präprozessor allgemein, warum ist dieser zusätzliche Schritt beim übersetzen sinnvoll?

\paragraph{2. Erzeugen von Assembler-Code}
Erzeugen Sie nun aus dem C-Code Assembler Code und analysieren Sie diesen: Welche Konstrukte im Assembler-Code entsprechen i, sum, lower und UPPER?

\paragraph{3. Optimierter Code}
Erzeugen Sie nun optimierten Assembler Code. Was macht das Assemblerprogramm nun? Erklären Sie dieses Verhalten.

\paragraph{4. Disassemblierung}
Wie viele Byte Maschinencode werden benötigt um zwei Register zu addieren?

%--------------------------------------------------
\subsection{Inline-Funktionen}

\paragraph{1.}
Übersetzen Sie diese Funktionen nach MIPS! Wie viele Instruktionen werden benötigt?

\paragraph{2.}
Schreiben Sie die Funktion minOfMax in C-ähnlichen Pseudo-Code um, indem Sie die enthaltenen Funktionsaufrufe als inine Funktionen abbilden!

\paragraph{3.}
Übersetzen Sie die modifizierte Funktion ebenfalls nach MIPS! Wie viele Instruktionen werden jetzt benötigt?

%----------------------------------------------------------------------------------------
\section{Pipelines}
\subsection{Pipeline}

\paragraph{1.}
Erweitern Sie das Diagramm um die benötigte Verzögerung!

\paragraph{2.}
Wie viele Takte lang muss die Pipeline verzögert werden?

\paragraph{3.}
Welchen Beschleunigung wurde mit der Pipeline für diesen Code erreicht? Gehen Sie davon aus, dass für einen Takt mit Pipelining $200 ps$ benötigt werden. Ohne Pipelining dauert ein Takt $800 ps$.

%--------------------------------------------------
\subsection{Pipeline Recorder}

\paragraph{1.}
Geben Sie den umgeordneten Quelltext sowie ein Ablaufdiagramm an, aus dem hervorgeht, welcher Befehl in welcher Stufe und in welchem Takt durchläuft.

\paragraph{2.}
Wie viele Takte lang muss die Pipeline verzögert werden?

\paragraph{3.}
Welche Beschleunigung wurde mit der Pipeline für diesen Code erreicht? Gehen Sie davon aus, dass für einen Takt mit Pipelining $200 ps$ benötigt werden. Ohne Pipelining dauert ein Takt $800 ps$.

%----------------------------------------------------------------------------------------
\section{Caches}
\subsection{Cache-Design}

\paragraph{1.}
Geben Sie für beide Strategien die mittlere Zugriffszeit bei Leseanfragen in Abhängigkeit von Trefferrate $r_{h}$, Cache-Zugriffszeit $t_{C}$ und Arbeitsspeicher-Zugriffszeit $t_{M}$ an.

\paragraph{2.}
Wie groß muss die reduzierte Trefferrate $r'_{h}$ mindestens sein, damit die zweite Strategie besser ist?

\paragraph{3.}
Ist es sinnvoller, bei einem Direct-Mapped-Cache die höchstwertigen oder niedrigstwertigen Bits der Adresse als Index zu verwenden? Begründen Sie Ihre Antwort!

%--------------------------------------------------
\subsection{Cache}

\paragraph{1.}
Warum werden in Computern Caches verwendet?

\paragraph{2.}
Was ist der Unterschied zwischen direkt abgebildeten Caches und vollassoziativen Caches? Nennen Sie je einen Vorteil der beiden Varianten!

\paragraph{3.}
Nennen Sie drei mögliche, realistische Verdrängungsstrategien bei einem voll-assoziativem Cache.

\paragraph{4.}
Vervollständigen Sie die Tabelle 1 auf der nächsten Seite, die einen direkt abgebildeten Cache mit 4 Blöcken beschreibt.

\begin{itemize}
\item[a)] Geben Sie für jede Anfrage an, ob es zu einem Cache-Hit oder einem Cache-Miss kommt und tragen Sie ggf. neu in den Cache kommende Werte entsprechend ein!
\item[b)] Setzen Sie an den entsprechenden Stellen das Dirty Bit und geben Sie an, wenn ein Wert aus dem Cache in den Arbeitsspeicher zurückgeschrieben werden muss!
\end{itemize}

%----------------------------------------------------------------------------------------
\section{Caches und Speichervirtualisierung}
\subsection{Caches}

\paragraph{1.}
Wie viele Speicherzellen benötigt dieser Cache insgesamt? Zeichnen Sie die Struktur eines solchen Caches und geben Sie die Breite der enthaltenen Felder in Bits an!

\paragraph{2.}
Geben Sie die mittlere Zugriffszeit bei Leseanfragen in Abhängigkeit von den beiden Trefferraten $r_{h1}$ und $r_{h2}$, den jeweiligen Cache-Zugriffszeiten $t_{C1}$ und $t_{C2}$ sowie der Arbeitsspeicher-Zugriffszeit $t_{MEM}$ an!

%--------------------------------------------------
\subsection{Speichervirtualisierung}

\paragraph{1.}
Beschreiben Sie, wie mit Hilfe der Seitentabelle aus der virtuelle Adresse die Adresse im physikalischen Arbeitsspeicher ermittelt wird!

\paragraph{2.}
Wie viele virtuelle Seiten gibt es im virtuellen Speicher?

\paragraph{3.}
Wie viele Seiten gibt es im physikalischen Speicher?

\paragraph{4.}
Wie viel Speicher benötigt die Seitentabelle, wenn in jeder Zeile nur der Index der dazugehörenden physikalischen Seite und keine weiteren Metainformationen gehalten werden?

%----------------------------------------------------------------------------------------

\end{document}